# VSCode配置C&#43;&#43;环境


由于笔者太懒,加之本文主要是为方便回顾流程所写,只会在一些笔者遇到的问题上详细说明,不会像参考链接中的大多数博客那样详细,orz

&lt;!--more--&gt; 

## 1. VSCode搭建C&#43;&#43;开发环境

大学里其实没怎么认真配过VSCode开发环境, 以前写.c基本都是单文件的习题小练习, 跟着网上教程走一遍, 后面不怎么写了

现在是需要用C&#43;&#43;的三方库了, 回来配一下环境, 顺便熟悉一下C&#43;&#43;, 以后上班八成要用


### 1.1 前置准备

参见[GCC on Windows](https://code.visualstudio.com/docs/cpp/config-mingw), 按照步骤来就行, 可以与中文博客对照

主要就是安装VSCode, 安装MinGW(GCC在Windows上的版本), 安装VSCode的C/C&#43;&#43;插件

### 1.2 问题

事情一直到单文件编译调试都很顺利

这里先提一下VSCode是如何构建C&#43;&#43;开发流程的:

我们知道,VSC只是集成了一下GCC和GDB罢了,免去了你在命令行手动编译,链接的过程

博客一般都会提到初次build时,会提示你选择compiler(gcc, g&#43;&#43;, Clang等), 然后自动生成`.vscode/tasks.json`

形如
```json
{
  &#34;tasks&#34;: [
    {
      &#34;type&#34;: &#34;cppbuild&#34;,
      &#34;label&#34;: &#34;C/C&#43;&#43;: g&#43;&#43;.exe build active file&#34;,
      &#34;command&#34;: &#34;C:\\msys64\\ucrt64\\bin\\g&#43;&#43;.exe&#34;,
      &#34;args&#34;: [
        &#34;-fdiagnostics-color=always&#34;,
        &#34;-g&#34;,
        &#34;${file}&#34;,
        &#34;-o&#34;,
        &#34;${fileDirname}\\${fileBasenameNoExtension}.exe&#34;
      ],
      &#34;options&#34;: {
        &#34;cwd&#34;: &#34;${fileDirname}&#34;
      },
      &#34;problemMatcher&#34;: [&#34;$gcc&#34;],
      &#34;group&#34;: {
        &#34;kind&#34;: &#34;build&#34;,
        &#34;isDefault&#34;: true
      },
      &#34;detail&#34;: &#34;Task generated by Debugger.&#34;
    }
  ],
  &#34;version&#34;: &#34;2.0.0&#34;
}

```
不难看出, 这就类似一个脚本配置, 设定好cmd和args, 再自动build .cpp文件

自然的, 要编译链接多文件, 做一点小小改动即可...吗?

本来该是这样的 orz

```json
{
    &#34;version&#34;: &#34;2.0.0&#34;,
    &#34;tasks&#34;: [
        {
            &#34;type&#34;: &#34;cppbuild&#34;,
            //&#34;type&#34;: &#34;shell&#34;,
            &#34;label&#34;: &#34;GCC Compiler&#34;,
            &#34;command&#34;: &#34;C:\\msys64\\ucrt64\\bin\\gcc.exe&#34;,
            &#34;shell&#34;: { 
                &#34;executable&#34;: &#34;powershell.exe&#34;
            },
            &#34;args&#34;: [
                &#34;-fdiagnostics-color=always&#34;,
                &#34;-g&#34;,
                //&#34;${file}&#34;,
                &#34;${workspaceFolder}\\*.cpp&#34;,
                &#34;-o&#34;,
                //&#34;${fileDirname}\\${fileBasenameNoExtension}.exe&#34;
                &#34;${workspaceFolder}\\AnyNameYouLike.exe&#34;
            ],
            &#34;options&#34;: {
                &#34;cwd&#34;: &#34;${workspaceFolder}&#34;
            },
            &#34;problemMatcher&#34;: [
                &#34;$gcc&#34;
            ],
            &#34;group&#34;: &#34;build&#34;,
            &#34;detail&#34;: &#34;compiler: C:\\msys64\\ucrt64\\bin\\gcc.exe&#34;
        },
    ]
}

```
我们用通配符指定所有`.cpp`文件, 这不就大功告成了?

然而实际build时会报错

```bash
 *  Executing task: GCC Compiler 

Starting build...
cmd /c chcp 65001&gt;nul &amp;&amp; C:\msys64\ucrt64\bin\gcc.exe -fdiagnostics-color=always -g C:\Users\fengjin\cppenv\*.cpp -o C:\Users\fengjin\cppenv\test.exe
cc1plus.exe: fatal error: C:\Users\fengjin\cppenv\*.cpp: Invalid argument
compilation terminated.

Build finished with error(s).

 *  The terminal process failed to launch (exit code: -1). 
 *  Terminal will be reused by tasks, press any key to close it. 
```
这个通配符`*`真的就以`*`的形式出现在命令里了, 没有展开

为了解决这个问题, 我在国内外疯狂检索,狠狠拷打AI, 然而没有令人信服的方案

一是出现这个bug很少; 

二来少有的回复或者无法解决, 或者直接建议别用睿智tasks.json弄多文件了, 直接上CMake/VS

记录一下我尝试过的方法:
1. 使用不同形式的通配符: `//*.cpp` , `//**.cpp`, `\*.cpp`, `\\*.cpp`
2. 修改`type`属性为`shell`
3. 修改`command`属性为先调pwsh.exe,再拼接gcc编译
4. 修改`command`的编译器为`g&#43;&#43;`, 同时修改C/C&#43;&#43;插件的设置`c_cpp_properties.json`, `compilerPath`也改成`g&#43;&#43;`

...都不行orz


## 2. CMake

人不能在一棵树上吊死, 既然还有其他多文件编译的方案, 先去试试

### 2.1 前置准备

去官网下载安装一下[CMake](https://cmake.org/)即可



### 2.2 最简实践

笔者学习CMake时总觉得不爽利, 有种迟滞感

自己分析了一下, 感觉是没有将VSCode插件方式和命令行方式分清楚导致的, 毕竟插件就是为简化命令行而被开发的

CMake的教程, 大多只是简短给出一个作者的最简实践 
由于时间, ,版本和一些忽略未提及的配置原因, 并不能在笔者这里完美复刻, 导致我觉得别扭, 没学明白一样

于是, 我决定分开来学, 先学明白命令行的最简实践, 再迁移到插件上去

在这一部分差不多要写完的时候, 又翻到一篇博客, 思路类似, 写的不错, 值得参考
[CMake在Windows环境下Visual Studio Code的使用](https://www.cnblogs.com/dapenson/p/17135239.html)

#### 2.2.1命令行

主要参考这一篇[Windows下CMake编译环境搭建](https://zhuanlan.zhihu.com/p/576408483)

创建`CMakeLists.txt`, `src/`, `build/`

```txt
cmake_minimum_required(VERSION 3.5.0)

project(CppEnv VERSION 0.1.0 LANGUAGES C CXX)

add_executable(CppEnv src/main.cpp)

```
`cd`到`build`下面执行

```bash
cmake .. -G “MinGW Makefiles”
```
使用`..`是因为`CMakeLists.txt`在上一级文件夹, 
使用`-G &#34;MinGW Makefiles&#34;` 指定生成器. 告诉 CMake 生成与 MinGW 编译器和 Make 工具兼容的 Makefile 文件。

笔者在VSCode里直接cmake使用的似乎是微软的方案构建, 出现很多奇怪的文件, 对于初学很不友好, 分散注意力.


#### 2.2.2 VSCode CMake Tool

参考[cmake-quickstart](https://code.visualstudio.com/docs/cpp/cmake-quickstart)
`Ctrl&#43;Shift&#43;P`调出命令窗口，`CMake Quick Start`逐步进行

注意最后有一步`Add a New Preset`,  为你的项目生成一个`CMakePresets.json`



```txt
Preset 允许我们预先定义好不同的构建配置，包括：

生成器（Generator）： 例如 &#34;MinGW Makefiles&#34;、&#34;Visual Studio 17 2022&#34; 等。
构建类型（CMAKE_BUILD_TYPE）： 例如 Debug、Release 等。
编译器（CMAKE_CXX_COMPILER）： 例如 g&#43;&#43;.exe、clang&#43;&#43;.exe 等。
其他构建选项： 例如编译标志、链接库等。
```

示例如下

```json
{
    &#34;version&#34;: 8,
    &#34;configurePresets&#34;: [
        {
            &#34;name&#34;: &#34;GCC&#34;,
            &#34;displayName&#34;: &#34;GCC in Debug Mode&#34;,
            &#34;description&#34;: &#34;Using compilers: C = C:\\msys64\\ucrt64\\bin\\gcc.exe, CXX = C:\\msys64\\ucrt64\\bin\\g&#43;&#43;.exe&#34;,
            &#34;generator&#34;: &#34;MinGW Makefiles&#34;,	
            &#34;binaryDir&#34;: &#34;${sourceDir}/out/build/${presetName}&#34;,
            &#34;cacheVariables&#34;: {
                &#34;CMAKE_INSTALL_PREFIX&#34;: &#34;${sourceDir}/out/install/${presetName}&#34;,
                &#34;CMAKE_C_COMPILER&#34;: &#34;C:/msys64/ucrt64/bin/gcc.exe&#34;,
                &#34;CMAKE_CXX_COMPILER&#34;: &#34;C:/msys64/ucrt64/bin/g&#43;&#43;.exe&#34;,
                &#34;CMAKE_BUILD_TYPE&#34;: &#34;Debug&#34;
            }
        }
    ]
}
```





### 2.3 CMakeLists.txt

直接来一个示例说明
好的，这是一个以初学者常用命令为例，并添加注释的 `CMakeLists.txt` 文件示例。注释会直接写在文件里，方便你理解每一步的作用。

```cmake
cmake_minimum_required(VERSION 3.10) # CMake 的最低版本要求，通常项目开始就写上

## 项目基本设置 ##
project(MyProject) # 定义项目名称，这里是 &#34;MyProject&#34;, 会影响生成的可执行文件名等

## 设置 C&#43;&#43; 标准 (可选，但推荐) ##
set(CMAKE_CXX_STANDARD 14) # 设置 C&#43;&#43; 标准为 C&#43;&#43;14，也可以是 11, 17, 20 等
set(CMAKE_CXX_STANDARD_REQUIRED ON) # 要求必须使用指定的 C&#43;&#43; 标准
set(CMAKE_CXX_EXTENSIONS OFF) # 关闭编译器特定的扩展

## 添加源文件 ##
# 方法一:  显式列出源文件 (当源文件不多时推荐)
# add_executable(my_program main.cpp utils.cpp)

# 方法二: 使用 file(GLOB) 自动查找源文件 (适用于源文件较多的情况，但注意新增文件后可能需要重新运行 CMake)
file(GLOB SOURCES &#34;*.cpp&#34;) # 查找当前目录下所有 .cpp 文件，并存放到 SOURCES 变量中
add_executable(my_program ${SOURCES}) # 使用 SOURCES 变量里的源文件来创建名为 my_program 的可执行文件

## 添加头文件包含目录 (如果你的头文件不在标准位置) ##
# 如果你的头文件都放在与源文件相同的目录，或者在系统标准目录，通常不需要手动添加
# 如果你的头文件放在例如 &#34;include&#34; 目录下，就需要添加
include_directories(include) # 添加当前目录下的 &#34;include&#34; 目录作为头文件搜索路径

## 链接库 (如果你的程序需要链接外部库) ##
# 例如，如果你的程序需要链接一个名为 &#34;mylib&#34; 的库 (假设这个库已经安装在系统里)
# target_link_libraries(my_program mylib) # 将 &#34;mylib&#34; 链接到 &#34;my_program&#34; 可执行文件

# 如果你需要链接特定路径下的库文件，可以使用绝对路径或相对路径
# 假设 &#34;mylib.a&#34; 或 &#34;mylib.so&#34; 在 &#34;lib&#34; 目录下
# target_link_libraries(my_program lib/mylib.a) # 链接静态库
# target_link_libraries(my_program lib/mylib.so) # 链接动态库 (共享库)

## 添加编译选项 (可选) ##
# 例如，添加 -Wall 和 -Wextra 警告选项
target_compile_options(my_program PRIVATE -Wall -Wextra) # PRIVATE 表示这些选项只对 my_program 生效

## 安装目标 (可选，如果你想将生成的可执行文件安装到指定位置) ##
install(TARGETS my_program # 指定要安装的目标，这里是可执行文件 my_program
        DESTINATION bin) # 指定安装路径，这里是 &#34;bin&#34; 目录，相对于安装前缀 (通常是 /usr/local/bin 或 /usr/bin)

## (更高级) 添加子目录 (如果你的项目比较复杂，有多个子模块) ##
# add_subdirectory(src) # 添加名为 &#34;src&#34; 的子目录，CMake 会去 src 目录下寻找 CMakeLists.txt

## 更多功能可以通过添加命令来实现，例如：
# - 定义编译宏: target_compile_definitions()
# - 设置源文件分组 (在 IDE 中显示): set_source_files_properties()
# - 自定义构建步骤: add_custom_command(), add_custom_target()
# - 测试: enable_testing(), add_test()
# - 打包: include(CPack), cpack()  (需要配置 CPack 相关变量)

# 这是一个基础的 CMakeLists.txt 示例，你可以根据你的项目需求逐步添加更多功能。
# 记住，CMake 的强大之处在于它的灵活性和可扩展性。

```

**这个 `CMakeLists.txt` 文件的主要功能包括:**

1. **指定 CMake 最低版本:** `cmake_minimum_required(VERSION 3.10)`  确保使用的 CMake 版本不会过低。
2. **定义项目名称:** `project(MyProject)`  为你的项目命名。
3. **设置 C&#43;&#43; 标准:** `set(CMAKE_CXX_STANDARD ...)`  指定项目使用的 C&#43;&#43; 语言标准 (可选但推荐)。
4. **添加源文件:**
   - 使用 `file(GLOB SOURCES &#34;*.cpp&#34;)` 自动查找 `.cpp` 源文件。
   - 使用 `add_executable(my_program ${SOURCES})` 创建名为 `my_program` 的可执行文件。
5. **添加头文件包含目录:**  `include_directories(include)`  如果你的头文件放在 &#34;include&#34; 目录下。
6. **链接库:** `target_link_libraries(my_program ...)`  如果你的程序需要链接外部库。
7. **添加编译选项:** `target_compile_options(my_program ...)`  例如添加警告选项。
8. **安装目标:** `install(TARGETS my_program DESTINATION bin)`  将生成的可执行文件安装到 `bin` 目录。
9. **(提及) 添加子目录:** `add_subdirectory(src)`  用于组织更复杂的项目结构。





## 3. VSCode &#43; WSL 

### 3.1 前置准备

安装 Windows SubSystem for Linux 和一个Unbuntu, VS Code安装WSL Extension

参考[Using C&#43;&#43; and WSL in VS Code]([Using C&#43;&#43; and WSL in VS Code](https://code.visualstudio.com/docs/cpp/config-wsl))



### 3.2 最简实践

可以参考[Windows&#43;WSL&#43;CMake&#43;VSCode: 个人认为运行调试C&#43;&#43;小项目的最佳配置 - 知乎](https://zhuanlan.zhihu.com/p/672745106)

其他部分其实和Windows下一般无二, 你需要编译器(gcc), 调试器(gdb), 构建工具(CMake), VS Code的各种插件(C/C&#43;&#43; Extension Pack).

需要额外做的, 是在wsl中的`workplaceFolder`以VS Code打开, `code .`

![](C:\Users\fengjin\OneDrive\Hugo\try\content\posts\VSCode-C&#43;&#43;\WSL打开VSCode.png)

WSL中只是装了VS Code 的Server, Windows宿主机的VS Code远程连接到Server.

所以WSL即使没有图形化桌面也有与Windows下一般无二的体验(更好, 因为你其实在Linux下).

但是WSL的插件和宿主机的是独立的, 需要重新装一下

![WSLVSCode插件](C:\Users\fengjin\OneDrive\Hugo\try\content\posts\VSCode-C&#43;&#43;\WSLVSCode插件.png)




## 参考链接

都在行文中了


---

> 作者: Kissy  
> URL: https://fengjin2333.github.io/posts/vscode%E9%85%8D%E7%BD%AEc-%E7%8E%AF%E5%A2%83/  

